pub mod transactions;

// Copyright 2023 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use alloy_primitives::{Address, TxHash, U256};
use alloy_rlp::Encodable;
use serde::{Deserialize, Serialize};

use crate::{keccak::keccak, signature::TxSignature};

use self::transactions::EthereumTxEssence;
pub type EthereumTransaction = Transaction<EthereumTxEssence>;

/// Represents a complete Ethereum transaction, encompassing its core essence and the
/// associated signature.
///
/// The `Transaction` struct encapsulates both the core details of the transaction (the
/// essence) and its cryptographic signature. The signature ensures the authenticity and
/// integrity of the transaction, confirming it was issued by the rightful sender.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Transaction<E: TxEssence> {
    /// The core details of the transaction, which include its type (e.g., legacy,
    /// EIP-2930, EIP-1559) and associated data (e.g., recipient address, value, gas
    /// details).
    pub essence: E,
    /// The cryptographic signature associated with the transaction, generated by signing
    /// the transaction essence.
    pub signature: TxSignature,
}

pub trait TxEssence: Encodable + Clone {
    /// Determines the type of the transaction based on its essence.
    ///
    /// Returns a byte representing the transaction type:
    /// - `0x00` for Legacy transactions.
    /// - `0x01` for EIP-2930 transactions.
    /// - `0x02` for EIP-1559 transactions.
    fn tx_type(&self) -> u8;
    /// Retrieves the gas limit set for the transaction.
    ///
    /// The gas limit represents the maximum amount of gas units that the transaction
    /// is allowed to consume. It ensures that transactions don't run indefinitely.
    fn gas_limit(&self) -> U256;
    /// Retrieves the recipient address of the transaction, if available.
    ///
    /// For contract creation transactions, this method returns `None` as there's no
    /// recipient address.
    fn to(&self) -> Option<Address>;
    /// Recovers the Ethereum address of the sender from the transaction's signature.
    ///
    /// This method uses the ECDSA recovery mechanism to derive the sender's public key
    /// and subsequently their Ethereum address. If the recovery is unsuccessful, an
    /// error is returned.
    fn recover_from(&self, signature: &TxSignature) -> anyhow::Result<Address>;
    /// Computes the length of the RLP-encoded payload in bytes.
    ///
    /// This method calculates the combined length of all the individual fields
    /// of the transaction when they are RLP-encoded.
    fn payload_length(&self) -> usize;
    /// RLP encodes the transaction essence and signature into the provided `out` buffer.
    fn encode_with_signature(&self, signature: &TxSignature, out: &mut dyn alloy_rlp::BufMut);
    /// Computes the length of an encompassing RLP-encoded [Transaction] struct in bytes.
    ///
    /// The computed length includes the lengths of the encoded transaction essence and
    /// signature. If the transaction type (as per EIP-2718) is not zero, an
    /// additional byte is added to the length.
    fn length(transaction: &Transaction<Self>) -> usize;
}

/// Provides RLP encoding functionality for the [Transaction] struct.
///
/// This implementation ensures that the entire transaction, including its essence and
/// signature, can be RLP-encoded. The encoding process also considers the EIP-2718
/// transaction type.
impl<E: TxEssence> Encodable for Transaction<E> {
    /// Encodes the [Transaction] struct into the provided `out` buffer.
    ///
    /// The encoding process starts by prepending the EIP-2718 transaction type, if
    /// applicable. It then joins the RLP lists of the transaction essence and the
    /// signature into a single list. This approach optimizes the encoding process by
    /// reusing as much of the generated RLP code as possible.
    #[inline]
    fn encode(&self, out: &mut dyn alloy_rlp::BufMut) {
        // prepend the EIP-2718 transaction type
        match self.essence.tx_type() {
            0 => {}
            tx_type => out.put_u8(tx_type),
        }
        // encode according to essence type
        self.essence.encode_with_signature(&self.signature, out);
    }

    /// Computes the length of the RLP-encoded [Transaction] struct in bytes.
    ///
    /// The computed length includes the lengths of the encoded transaction essence and
    /// signature. If the transaction type (as per EIP-2718) is not zero, an
    /// additional byte is added to the length.
    #[inline]
    fn length(&self) -> usize {
        <E as TxEssence>::length(self)
    }
}

impl<E: TxEssence> Transaction<E> {
    /// Calculates the Keccak hash of the RLP-encoded transaction.
    ///
    /// This hash uniquely identifies the transaction on the Ethereum network.
    pub fn hash(&self) -> TxHash {
        keccak(alloy_rlp::encode(self)).into()
    }

    /// Recovers the Ethereum address of the sender from the transaction's signature.
    ///
    /// This method uses the ECDSA recovery mechanism to derive the sender's public key
    /// and subsequently their Ethereum address. If the recovery is unsuccessful, an
    /// error is returned.
    pub fn recover_from(&self) -> anyhow::Result<Address> {
        self.essence.recover_from(&self.signature)
    }
}
